use std::collections::HashMap;
use wgpu::{Device, Extent3d, Queue, Texture, TextureView};

/// MSDF Atlas JSON Schema
/// Generated by msdf-atlas-gen with flags:
/// msdf-atlas-gen -font roboto.ttf -type msdf -format png -json metrics.json -imageout atlas.png
///
/// Expected JSON structure:
/// ```json
/// {
///   "atlas": {
///     "type": "msdf",
///     "distanceRange": 4.0,
///     "size": 512,
///     "width": 512,
///     "height": 512
///   },
///   "metrics": {
///     "emSize": 1.0,
///     "lineHeight": 1.2,
///     "ascender": 0.928,
///     "descender": -0.244,
///     "underlineY": -0.1,
///     "underlineThickness": 0.05
///   },
///   "glyphs": [
///     {
///       "unicode": 65,
///       "advance": 0.684,
///       "planeBounds": {
///         "left": 0.0,
///         "bottom": 0.0,
///         "right": 0.684,
///         "top": 0.716
///       },
///       "atlasBounds": {
///         "left": 0,
///         "bottom": 0,
///         "right": 42,
///         "top": 44
///       }
///     }
///   ]
/// }
/// ```

#[derive(Debug, Clone, Copy)]
pub struct GlyphMetrics {
    pub unicode: u32,
    pub advance: f32,

    pub plane_bounds_left: f32,
    pub plane_bounds_bottom: f32,
    pub plane_bounds_right: f32,
    pub plane_bounds_top: f32,

    pub atlas_bounds_left: u32,
    pub atlas_bounds_bottom: u32,
    pub atlas_bounds_right: u32,
    pub atlas_bounds_top: u32,
}

#[derive(Debug, Clone, Copy)]
pub struct MSDFAtlasMetrics {
    pub distance_range: f32,
    pub atlas_width: u32,
    pub atlas_height: u32,
    pub em_size: f32,
    pub line_height: f32,
    pub ascender: f32,
    pub descender: f32,
}

pub struct MSDFAtlas {
    _texture: Texture,
    view: TextureView,
    metrics: MSDFAtlasMetrics,
    glyphs: HashMap<u32, GlyphMetrics>,
}

impl MSDFAtlas {
    /// Load MSDF atlas from PNG texture data and JSON metrics
    ///
    /// TODO: Assets must be generated offline using:
    /// msdf-atlas-gen -font Roboto-Regular.ttf -type msdf -format png \
    ///   -charset charset.txt -json roboto.json -imageout roboto.png
    pub fn from_bytes(
        device: &Device,
        queue: &Queue,
        png_data: &[u8],
        json_data: &str,
    ) -> Result<Self, String> {
        let (atlas_metrics, glyph_metrics) = Self::parse_json(json_data)?;

        let image = image::load_from_memory(png_data)
            .map_err(|e| format!("Failed to load PNG: {}", e))?
            .to_rgba8();

        let (width, height) = image.dimensions();

        if width != atlas_metrics.atlas_width || height != atlas_metrics.atlas_height {
            return Err(format!(
                "Atlas size mismatch: JSON says {}x{}, PNG is {}x{}",
                atlas_metrics.atlas_width, atlas_metrics.atlas_height, width, height
            ));
        }

        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("MSDF Atlas Texture"),
            size: Extent3d {
                width,
                height,
                depth_or_array_layers: 1,
            },
            mip_level_count: 1,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba8Unorm,
            usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
            view_formats: &[],
        });

        queue.write_texture(
            wgpu::TexelCopyTextureInfo {
                texture: &texture,
                mip_level: 0,
                origin: wgpu::Origin3d::ZERO,
                aspect: wgpu::TextureAspect::All,
            },
            &image,
            wgpu::TexelCopyBufferLayout {
                offset: 0,
                bytes_per_row: Some(4 * width),
                rows_per_image: Some(height),
            },
            Extent3d {
                width,
                height,
                depth_or_array_layers: 1,
            },
        );

        let view = texture.create_view(&wgpu::TextureViewDescriptor::default());

        Ok(Self {
            _texture: texture,
            view,
            metrics: atlas_metrics,
            glyphs: glyph_metrics,
        })
    }

    fn parse_json(json: &str) -> Result<(MSDFAtlasMetrics, HashMap<u32, GlyphMetrics>), String> {
        let v: serde_json::Value =
            serde_json::from_str(json).map_err(|e| format!("JSON parse error: {}", e))?;

        let atlas = &v["atlas"];
        let metrics = &v["metrics"];
        let glyphs = v["glyphs"].as_array().ok_or("Missing glyphs array")?;

        let atlas_metrics = MSDFAtlasMetrics {
            distance_range: atlas["distanceRange"].as_f64().unwrap_or(4.0) as f32,
            atlas_width: atlas["width"].as_u64().ok_or("Missing atlas width")? as u32,
            atlas_height: atlas["height"].as_u64().ok_or("Missing atlas height")? as u32,
            em_size: metrics["emSize"].as_f64().unwrap_or(1.0) as f32,
            line_height: metrics["lineHeight"].as_f64().unwrap_or(1.2) as f32,
            ascender: metrics["ascender"].as_f64().unwrap_or(0.928) as f32,
            descender: metrics["descender"].as_f64().unwrap_or(-0.244) as f32,
        };

        let mut glyph_map = HashMap::new();

        for glyph in glyphs {
            let unicode = glyph["unicode"].as_u64().ok_or("Missing unicode")? as u32;
            let advance = glyph["advance"].as_f64().ok_or("Missing advance")? as f32;

            let plane = &glyph["planeBounds"];
            let atlas = &glyph["atlasBounds"];

            let metrics = GlyphMetrics {
                unicode,
                advance,
                plane_bounds_left: plane["left"].as_f64().unwrap_or(0.0) as f32,
                plane_bounds_bottom: plane["bottom"].as_f64().unwrap_or(0.0) as f32,
                plane_bounds_right: plane["right"].as_f64().unwrap_or(0.0) as f32,
                plane_bounds_top: plane["top"].as_f64().unwrap_or(0.0) as f32,
                atlas_bounds_left: atlas["left"].as_f64().unwrap_or(0.0) as u32,
                atlas_bounds_bottom: atlas["bottom"].as_f64().unwrap_or(0.0) as u32,
                atlas_bounds_right: atlas["right"].as_f64().unwrap_or(0.0) as u32,
                atlas_bounds_top: atlas["top"].as_f64().unwrap_or(0.0) as u32,
            };

            glyph_map.insert(unicode, metrics);
        }

        Ok((atlas_metrics, glyph_map))
    }

    pub fn texture_view(&self) -> &TextureView {
        &self.view
    }

    pub fn metrics(&self) -> &MSDFAtlasMetrics {
        &self.metrics
    }

    pub fn get_glyph(&self, unicode: u32) -> Option<&GlyphMetrics> {
        self.glyphs.get(&unicode)
    }
}
